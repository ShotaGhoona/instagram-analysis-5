# B0301: 投稿分析API実装

## 概要
フロントエンドのフィルター機能と完全対応する投稿分析APIエンドポイントを実装。フィルタリング、ソート、エンゲージメント率計算機能を提供し、既存のmockデータベースの実データ置き換えを可能にする。

## 実装戦略

### 1. APIエンドポイント設計 (1.5時間)
#### 投稿分析API仕様策定
- `GET /analytics/posts/{account_id}` エンドポイント設計
- クエリパラメータ仕様（フロントフィルター完全対応）
- レスポンス形式の標準化

#### クエリパラメータ仕様
```python
# フィルタリングパラメータ
start_date: Optional[date] = None    # 開始日フィルター
end_date: Optional[date] = None      # 終了日フィルター  
media_type: Optional[List[str]] = [] # ['IMAGE', 'VIDEO', 'CAROUSEL_ALBUM']

# ソートパラメータ
sort_by: str = 'timestamp'           # timestamp, like_count, reach, engagement_rate
sort_order: str = 'desc'             # asc, desc

# ページネーション
limit: int = 25                      # デフォルト25件
offset: int = 0                      # オフセット
```

### 2. データベースクエリ実装 (2.5時間)
#### Repository層拡張
- `repositories/instagram_repository.py` の `get_posts_analytics` メソッド拡張
- 複雑なJOINクエリ（media_posts + daily_media_stats）
- フィルタリング条件のSQL化
- エンゲージメント率の計算式をSQLで実装

#### SQL実装例
```sql
SELECT 
  mp.ig_media_id,
  mp.timestamp,
  mp.media_type,
  mp.caption,
  mp.media_url,
  mp.thumbnail_url,
  mp.permalink,
  COALESCE(dms.like_count, 0) as like_count,
  COALESCE(dms.comments_count, 0) as comments_count,
  COALESCE(dms.reach, 0) as reach,
  COALESCE(dms.views, 0) as views,
  COALESCE(dms.shares, 0) as shares,
  COALESCE(dms.saved, 0) as saved,
  -- エンゲージメント率計算
  ROUND(
    CASE 
      WHEN COALESCE(dms.reach, 0) = 0 THEN 0.0
      ELSE (COALESCE(dms.like_count, 0) + COALESCE(dms.comments_count, 0) + 
            COALESCE(dms.shares, 0) + COALESCE(dms.saved, 0)) 
           * 100.0 / COALESCE(dms.reach, 1)
    END, 1
  ) as engagement_rate
FROM media_posts mp
LEFT JOIN daily_media_stats dms ON mp.ig_media_id = dms.ig_media_id
WHERE mp.ig_user_id = %s
  AND (%s IS NULL OR mp.timestamp >= %s)  -- start_date filter
  AND (%s IS NULL OR mp.timestamp <= %s)  -- end_date filter  
  AND (%s IS NULL OR mp.media_type = ANY(%s))  -- media_type filter
ORDER BY {sort_column} {sort_order}
LIMIT %s OFFSET %s
```

### 3. API実装 (2時間)
#### FastAPIエンドポイント作成
- `api/analytics.py` の `get_posts_analytics` エンドポイント実装
- Pydanticモデルでレスポンス型定義
- バリデーション・エラーハンドリング

#### レスポンスモデル
```python
class PostAnalyticsResponse(BaseModel):
    ig_media_id: str
    ig_user_id: str
    timestamp: datetime
    media_type: MediaType
    caption: Optional[str]
    media_url: str
    thumbnail_url: Optional[str]
    permalink: str
    like_count: int
    comments_count: int
    reach: Optional[int]
    views: Optional[int]
    shares: Optional[int]
    saved: Optional[int]
    engagement_rate: float  # 小数点1桁
```

### 4. フロントエンド API統合 (1.5時間)
#### API Client更新
- `lib/api.ts` の `getPostsAnalytics` メソッド拡張
- フィルターパラメータの送信対応
- TypeScript型定義の同期

#### useFilterState フック拡張
```tsx
export function useFilterState(accountId: string) {
  const [isLoading, setIsLoading] = useState(false)
  const [posts, setPosts] = useState<MediaPost[]>([])
  
  // API呼び出しでフィルタリング済みデータ取得
  const fetchFilteredPosts = async () => {
    setIsLoading(true)
    try {
      const result = await apiClient.getPostsAnalytics(accountId, {
        start_date: dateRange?.from?.toISOString().split('T')[0],
        end_date: dateRange?.to?.toISOString().split('T')[0],
        media_type: mediaTypes
      })
      setPosts(result)
    } finally {
      setIsLoading(false)
    }
  }
  
  // フィルター変更時の自動再取得
  useEffect(() => {
    fetchFilteredPosts()
  }, [dateRange, mediaTypes])
}
```

### 5. テスト・デバッグ (0.5時間)
#### API動作確認
- Postmanまたはcurlでエンドポイント確認
- フィルターパラメータの動作確認
- エンゲージメント率計算の精度確認

## 完了条件
- [ ] APIエンドポイントが正常に動作する
- [ ] 日付フィルターが正確に適用される
- [ ] メディアタイプフィルターが正確に適用される
- [ ] エンゲージメント率が小数点1桁で正確に計算される
- [ ] フロントエンドでmockデータからAPIデータに切り替わる
- [ ] フィルター操作でAPIが呼び出される
- [ ] レスポンス時間が許容範囲内（<2秒）

## PoC配慮
- **複雑なソート機能は最小限**: timestamp, like_count程度
- **ページネーション簡素化**: limit/offset方式
- **エラーハンドリング基本のみ**: 4xx/5xxの基本対応
- **パフォーマンス最適化は後回し**: インデックス活用程度

## スコープ外機能
```python
# TODO: 高度なソート機能（複数カラム等）
# TODO: 全文検索機能（caption検索）
# TODO: キャッシュ機能（Redis等）
# TODO: ページネーション情報（total_count等）
# TODO: 集計値API（平均エンゲージメント率等）
```

## 技術詳細

### データベースパフォーマンス考慮
```sql
-- 必要インデックス（パフォーマンス向上）
CREATE INDEX idx_media_posts_user_timestamp ON media_posts(ig_user_id, timestamp DESC);
CREATE INDEX idx_media_posts_media_type ON media_posts(media_type);
CREATE INDEX idx_daily_media_stats_media_id ON daily_media_stats(ig_media_id);
```

### API実装例
```python
@router.get("/posts/{account_id}", response_model=List[PostAnalyticsResponse])
async def get_posts_analytics(
    account_id: str,
    start_date: Optional[date] = Query(None),
    end_date: Optional[date] = Query(None),
    media_type: Optional[List[str]] = Query([]),
    sort_by: str = Query('timestamp'),
    sort_order: str = Query('desc'),
    limit: int = Query(25, ge=1, le=100),
    offset: int = Query(0, ge=0),
    current_user: User = Depends(get_current_user)
):
    # アカウント存在確認
    account = await instagram_repository.get_by_id(account_id)
    if not account:
        raise HTTPException(status_code=404, detail="Account not found")
    
    # フィルタリング済み投稿データ取得
    posts = await instagram_repository.get_posts_analytics(
        account_id=account_id,
        start_date=start_date,
        end_date=end_date,
        media_types=media_type,
        sort_by=sort_by,
        sort_order=sort_order,
        limit=limit,
        offset=offset
    )
    
    return posts
```

## 実装順序
1. **APIエンドポイント設計** → 仕様策定・パラメータ定義
2. **Repository層実装** → SQLクエリ・フィルタリング実装
3. **FastAPI実装** → エンドポイント・バリデーション実装
4. **API統合** → フロントエンド側のAPI呼び出し実装
5. **テスト・調整** → 動作確認・パフォーマンス調整

## 参考
- [既存Repository](../../backend/repositories/instagram_repository.py)
- [フロントフィルター仕様](../../frontend/src/hooks/use-filter-state.ts)
- [API Client](../../frontend/src/lib/api.ts)
- [FastAPI公式ドキュメント](https://fastapi.tiangolo.com/)